#射程修正
根据 deltaY 和 vy 的符号，将存在4种情形。
+ deltaY > 0 && vy < 0: 直接排除。
+ deltaY < 0: 常见情形。只需以 y < deltaY 为脱出条件。
	+ 针对不同的情况，需要用不同的函数（脱出条件，以及记录可能存在的第一个解）。虽然核心迭代的语句一样，但从游戏内的效率考虑，分设多个SQF比较好。
		+ 以 y < deltaY 为脱出条件。当 _vy x _vy0 <= 0 时，说明符号相反，此时因为y速度过小，不提供x坐标的修正。
	+ 这种情况只有唯一解，不需要考虑修正的方向。
		+ 必要的时候，可取30°为最大射程临界仰角（实际上是介于30到45中间的值，初速度越大，临界值越小）。
	+ 一旦迭代导致误差增大（采用1.05倍+10米），则认为速度不合适，删除子弹。
+ deltaY > 0 && vy > 0: 将会存在两个解或无解（1个解的情形仅存在于数学上，实践中不考虑）。
  对两个解的情形，AI提供的仰角计算出来的两个数值往往和实际值都有很大的偏差，而这两个偏差反而往往相差不大。两个解要求的修正方向也不同，事实上存在更多的情形。
	+ 初始仰角无法达到高度: 排除。
	+ 初始仰角能够达到高度: 如果误差没有小得很离谱，则**认为此时初速度达标。**由于存在两个解，它们将正半轴分为三个区间，因此存在三种可能的情形。
	+ 收敛性分析: 
		+ 目标近于range1: 只需提高仰角。range1总能收敛到target，并且提高仰角的操作不会导致无解情形的发生（但可能需要避免仰角大于90°）。
		+ 目标远于range2: 在range2附近做局部的线性插值。如果误差随着迭代被放大，则认为初速度能力不足，退出脚本（另外，需要对无解的情形做保护）。
		+ 目标介于二者之间: 持续增大仰角，则必然有range2解；减小仰角，则既可以有range2解，也可以有range1解（但只会出现其中之一）。
			+ 从单调性来分析，考虑xy图像，它是上凸的。当θ从零增加到90时，它和 y = deltaY 上某点只会相交最多2次，其中之一是range2解。
			+ 从实战角度考虑，**载具最大仰角以及AI瞄准机制都倾向于往减小仰角的方向修正。**
				+ **在小仰角区域，从较大的仰角向前修正时，将会导致仰角减少过多，这将导致“无解”的情形。**
			+ **采用“双向迭代”的方式。**
				+ 将初速度、坐标差取反，摩擦力系数取反，可以得到以原问题的终值为初值的柯西问题。
				+ 采用合适的终点，可以得到收敛速度较快的迭代法。
				+ *这一方式很适合“介于二者之间”的情形，收敛具有很快的速度。*
		+ 以高度差作为迭代的指标如何呢？
			+ 以距离差作为指标迭代时存在高度问题，但此处的前2种情形里，x坐标是可以保证达到的。
			+ 情况可以进一步简并。由于大前提是 deltaY > 0，因此总是可以用 y < 0 作为终止条件的。这种情况下，甚至没有必要在第一步对高度做排除。
			+ **但是对于长距离射击，因为AI会采用很智障的小仰角，如果高度差不大但 >0，将导致SQF函数进入炮弹落地的世界线。**
				+ 需要让AI尝试3次增加仰角，使得height能够达到。这个只是经验的数值，不是可靠的结果。
	+ 技术细节: 
		+ SQF设计: 当vy0和vy异号时，二者的平均值接近0，此时不宜做坐标修正。返回2个range解的函数，还需要另外返回一个bool值表示高度异常与否。
		+ SQF嵌套：主循环仍然是EH的SQS脚本执行，从效率来考虑，或许用SQF管理循环会更合适。M270实测的效率更高。
		+ 角度保护：对于减小仰角的迭代，使用一个比例来控制迭代效果，此外在无解发生时，增加角度，计数变量增加一个小数。**采用x迭代后这个设计可以取消了。**
##炮击模块的曳光弹、marker标记
+ 迭代终止后，如果子弹已经null了，则不再启动后续的速度、坐标重置及炮击图标EH。
+ 以3秒（数值取3.2）为界，如果炮弹类型的生命长于3秒，则到时间后从remote的shell上再一次读取状态，并生成效果弹。
	+ 因此需要追加传入remote shell。
+ 测试，在模拟炮弹null之后，追加一次对实际shell的读取、重置（以是否lag为指标）。
	+ 同时测试getPosASL应用于drop的结果。**似乎还不错。但是ASL与否总该产生一些区别才对啊？**
##火箭炮
设置local端持续地修改rocket的vectorDir，让炮弹方向和速度一致，看看效果（只要不lag就ok，需要10人以上测试。但延迟也可能是publicExec的缘故，需要观察）。