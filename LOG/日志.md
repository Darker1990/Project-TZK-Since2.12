## 2.12 v05
	+ Init.sqs里grpSetting以及Order等字段扔到某个脚本
	+ 测试setObjectTexture对视距外的效果
	+ AI单位远距离移动，对AICO有效。考虑使用向量内积，判定在锐角上最近的town，作为目的地。总是按town移动，对AICO有效，强化城镇的防御。
	+ AI步兵放置炸药的判定修改。读取弹夹的方式不必依赖于sqf，也无需特地分配_magazines的数组。
		+ 搜寻距离最近的敌建筑，也不必用sqf，由于预设了knowsAbout机制，那么只需要在已暴露的敌建筑里做距离判定即可。暴露建筑可以由server进行判定。
		+ 对AI坦克开炮也是同理。RES亦然，进入反抢和基地搜寻阶段，负担较重，有可能是对“最近敌建筑”搜寻有较大负担。
	+ 服务器FPS在1人、大量步兵时较低。坦克时不低。问题是什么呢？果然是拓展炸药包么？
	+ 调整摄像头dialog。
	+ KnowsAbout脚本对步兵、建筑有效，而vehicle没有挂载。会不会是它的缘故呢？研究整个KA系统。
## 2.12 v04
+ TZK Setting面板
	+ 某个选项变动之后，除bool矩阵要写入新的数值之外，脚本内的"_last"数组也要更新数据。
+ CIV
	+ **InitSpectator.sqs**里增设逻辑值bFreeMode用于切换模式。
	+ **Dialog Spectator.sqs**的Quit部分，更改cameraEffect的同时追加camCommit 0，并设置0.1的延时。
		+ （一度测试发现重新指派camSetTarget到_tracker是有效的，无需camCommit，但之后发现失败。）
		+ （这种设置也会失败。）
		+ Quit按钮暂时隐藏。【测试中】。
			+ _cam camCommand "manual off"关闭相机，关闭成功，但无法操纵player。
			+ player cameraEffect["terminate","back"]可以切换视角到player。
			+ 右上角group信息里，选中底端的east group无效，会选到res的组。是否group ID存在问题？还是面板的问题？
			+ 还是右上角group，选中队长时并不总能成功切换tracking单位。
	+ **UpdateSpectator.sqs**
		+ 设置一个"_posFreeMove"变量用于记录自由移动模式的坐标，初始化为spectator的起始位置，离开FreeMode时记录，下次进入时移回来。
		+ 主循环里设置一个判定，位于gameOver及alive之后，用于跳出主循环，停止坐标重置。
		+ FreeMode模式下要强制弹出进入载具的CIV。
		+ FreeMode模式设置循环，持续移除武器。退出后重新添加。
		+ 【是否有可能做成自由移动camera模式（含camera背景）】。
		+ 将spectator移动到"_posFreeMove"时，要将camSpec一并移过去。之后点击地图时不再需要调整camSpec，因此理由大概是在dialog、镜头、目标切换时，要等它们处理完毕才行。
	+ （其他镜头优化留待后续版本处理。）
+ 为使LF生产的固定翼不被建筑卡住，LF的sdDist数值设为35，和机场一致。
+ Call
	+ call grpSetting经常有错误信息提示。可能是SQF内启动时有问题。对SQF里的call grpSetting进行移除。
	+ 基于Scheduler的角度，将部分轻量级func函数由预编译SQF改为直接定义字符串，在SQS里通过call调用。
		+ 事实上颇有一些SQF的风格很像字符串，考虑到OFP并非一开始就引入SQF语法，一些function很有可能在早期开发CTI时以字符串形式调用，之后改成了SQF，然后SQF就一直被沿用。
		+ 考虑将轻量级SQF改为字符串。
			+ Vector函数的dot内积缺乏对3维向量的支持，一并补上。
			+ UpdateAttaching改写为字符串可能有危险。
			+ AddToUnitMatrix.sqf本质只是索引搜索，可以取消
			+ AddToStructMatrix.sqf只是单纯的写入，也可以取消。事实上还做了进一步的调整，见下。
				+ 顺带一提，一些函数调用矩阵structMatrix时并没有清理objNull，而是直接用等号赋值。
				+ HandleStructMatrixRemove执行了清理objNull的操作。在新的设计下它是不需要的。
			+ Server的MoveAI
			+ Server的Money，只是简单的运算，并没有特地调用sqf的意义，既然已经应用了SQS作为控制开关，那么继续沿用就是了（为了利用互斥保护数组）。
				+ InitUnitFactory在算钱时使用了互斥的前半部分，因此要改写为一个完整的互斥环节。
			+ Server的GetIdleFactory弃用，改为GetIdleFactories，后者改为字符串。
	+ 原有的一些字符串常数，此前没有意识到可以传参，本次它们也一并编辑，并收录于InitFunction脚本里。
+ 建筑系统
	+ 为了优化自动购买系统，首先需要对建筑系统进行调整。
	+ 大原则：出于兼容性考虑，虽然建筑单位多数 setDamage 0 不会像载具发生二次爆炸，但仍然坚持使用新单位替换原有单位。
	+ StructMatrix
		+ 受限于“替换”这一机制，需要设计合理的方法。原有建筑是必须要删除的，即使设置一定的延时，考虑到“延迟”的存在，这个机制仍然不稳定，不可以在远端使用find。
		+ 鉴于建造统一在server上完成，那么广播时设置server将矩阵中的索引一并传出。
		+ StructMatrix需要保证顺序。如果不在某个时刻对矩阵清理索引较小的objNull元素，数组规模将会无上限。
		+ 数量有限制的建筑目前不需要担心，那么需要对工事类建筑进行处理。利用之前定义的structsShelter来区别对待。
		+ AddToStructMatrix
			+ Server上只在BuildStruct、StructuresServerRemove里执行添加。改动后的机制需要一并获取索引并由发讯脚本传出。
			+ 由于BuildStruct是SQF，故需要在Server上设置一个脚本，添加到矩阵后直接传出索引用于发讯。
			+ ReplacePrimStruct里，删除原有建筑的机制，应当将删除单位的时间拖后，利用DeleteVehicleAfterDelay来处理。
				+ 将StructuresServerRemove的启动扔到最后，使用原有object获取索引，写入新的建筑（此处上锁），将索引和新建筑一并传入发讯脚本。
				+ StructuresServerRemove去除矩阵写入，将原有建筑扔到海外，并设置10秒延时后删除。
			+ SendStructBuilt在si的更高一位记录index。如果传入的是-1，则读取当前的数组规模。
			+ structsShelter类型单位，使用find objNull从起始位置替换删除单位。
		+ SendStructMatrixRemove.sqs
			+ 建筑制造统一由server完成，事实上只有server需要获取索引，player是被动接收索引。由于直接采用set执行写入，而删除则由delete的全局性完成，事实上不需要remove。
			+ 因此隐藏server的发讯入口，注释**SendStructMatrixRemove.sqs**的启动。因为矩阵里建筑的索引由server统一计算并发讯，client不可以再自行调整。
	+ Server上的structuresServer数组
		+ 这个数组用于记录建筑数组，在建筑损毁/拆除时将其他组件一并清理。
		+ 为应用find，改写为structServer和structsServer两个数组。前者用于存放0号组件，后者存放其他组件以及"_type"信息。
		+ 几个相关脚本的设置更改。原先整合到一个脚本的做法是不妥的。
	+ Server上的repairableStructureMatrix矩阵
		+ 用于存放待维修的建筑。因为数组格式的缘故，依赖于SQF函数执行维修。如果能够改写为SQS语法并应用互斥锁，将会比较方便。
			+ 多个单位维修完毕后都会启动ReplacedPrimStruct脚本。由于待维修的建筑已经被新的建筑在structServer中替换，但又没有立刻删除（走延时删除模式），会触发报错信息。
		+ 适应于find而拆分为0号组件+其他信息。增设repairableStructureInfo矩阵。
			+ 需要指出的是，为保证顺序，新损毁的建筑总是从末位插入，或替换末尾的objNull。因此在添加元素时，需要特殊处理。
			+ 设置一个从后向前搜索Null元素的函数。放弃原有的sqf。
		+ 将RepairStructure.sqf更改为SQS语法，由worker和support执行。mutexRepairStructure锁从ReplacePrimStruct移动到worker和support脚本里。
			+ 当维修完毕后，由worker和support在脚本的上锁片段将repairableSturcture的相应单位**set**为objNull，而非被动等待它被删除。
		+ 适应于数组元素格式的修改，其它调用脚本的语法做相应调整。
+ AI自动购买
	+ 这个脚本的设计原本就不够完善。增加了factory二值化解码后可能进一步加重负担。
	+ 从已有玩家的风格来看，倾向于大量使用AI自动购买，对真人玩家数不高的情形，AI相应地变多，负担加重。玩家下线后也进入这种情形，而且和笔者测试训练任务，纯爆坦克无压力的情形也不矛盾。
	+ 新的StructMatrix模式，工厂和矩阵中索引总是捆绑的。因此只需从matrix里用+号提取数组，清理null元素后对固定索引判断即可。
	+ UpdateLeader里每个队长每5秒启动一次SQS。这个设置在server的FPS较低时很危险。因此将整个脚本改为UpdateLeader的一个片段。
		+ 主循环的延时仍然为5秒。
		+ 跳转自动购买后执行判断。对于选取了购买方案的队伍，设置它总是从structMatrix里顺位与setting相一致的工厂购买。在工厂损毁时，不从递补的下一个工厂购买，维修完毕后恢复购买。
			+ 但是当工厂被拆除，或不修复而消失，则递补下一个工厂。
		+ 按原方案购买的模式，随机数要-0.5，否则可能选取到count附近，对应元素为nil，造成AddToUnitQueue报错。
			+ setect对非整数的处理，0.5以外的遵循四舍五入，但0.5总是选取到相邻的偶数而非奇数。
			+ Random命令取值范围是0~x，包含0但不包含x。减去0.5后，可以确保不选取到count。
	+ AICO设置在dev模式下购买步兵，用于调试server的FPS。
+ AI命令机制
	+ 将17组满员AI从pickup wait 99min改为don't use后，可以观察到server的FPS从38骤降到25。相关的操作是短时间内大量的busyClear，对全局数组变量执行清理和重新赋值操作。
	+ 因此考虑修改机制。
		+ 延时【暂时】不考虑，尝试使用find和set，在指定位置写入objNull起到擦除效果，写入时使用find objNull来写入或末位添加。
		+ in判定的两端【拟考虑】使用互斥锁保护，避免数组编辑过程中的in判定。
	+ 另一种可用的机制是利用skill值。CTI里默认单位的skill为1，那么可以用0.998和0.999来标识它。
		+ 设置了superAI的服务器是无法用skill的返回值的。2.01命令是否可能控制？或者任务提示。
		+ 需要验证它的变量与效果分别是全局的还是局部的。
		+ 对效果全局的情形，需要分析一下它的带宽负担。
	+ 此外，还有一种可行的做法，即设置throw和put的同类武器。不过它会在rearm执行时被覆盖，用于busy尚可，用于temporary就很不合适了。
	+ AI事件触发器涉及的补给单位记录数组CheckSupportUnits，也采用find和set的方式进行编辑。
	+ 一度在队伍order变更时导致服务器卡死。因此在所有orderMatrix, orderTempMatrix出现的脚本里，利用指针优化脚本的写法。
		+ AI队长的脚本特别处理。虽说此前一直也没有这么优化过，它应该不至于是问题的来源就是了。
		+ 同理处理aiSetting矩阵。
	+ 关闭AI步兵hit的事件触发器。
## 2.12 v03
+ 服务器减负
	+ Find命令。如果在sqf脚本里使用find，那么并没有实质上将服务器从sqf里解放出来。因此搜索使用find的sqf脚本。
		 + AddRearmData, EditRearmData的sqf脚本被删除，相关机制改写使得无需sqf。
		 + GetRearmData、GetUnitTypeFromObject因为被广泛使用，且被其它sqf调用，因此不删除它们，仅仅将它们与Server的sqf及少量sqs脱钩。GetUnitTypeFromObject只被Server的Order, OrderTemp (SQS)脚本使用。
		 + GetUnitTypeFromObject.sqf里，复制数组但不关联地址，只需使用"+"号。
	+ RES巡逻脚本
		+ **UpdateResPatrolGroup.sqs**脚本全面弃用SQF运算，以SQS的形式进行判定。
		+ PatrolPos的选取也是用SQS格式获取，每次判定延时0.1秒。
	+ **UpdateServer.sqs**里注释CheckDetachedVehicles的运行，无线电频道里已经有召回MHQ的选项。
+ AddWorker判定MHQ是否被拖曳，拖曳的MHQ从tug的位置生成工人。
+ **InitUnitTypes.sqs**中修改榴弹炮在购买列表里的名称（Limited）。修改Ka50的贴图，从插件而非player目录调用（之前没删干净）。
+ 修复Mortar的Equip脚本中残留"xj301"的bug。
+ 炮击功能
	+ 动态生成20个用于炮击的图标。**InitPlayer.sqs**里使用camCreate创造10个不可视H。暂不考虑于服务器的不可视H。
	+ 为玩家队伍命令增设炮击坐标设置/清除命令，以及Mortar/M46建筑、坦克/榴弹炮/Art坦克的炮击命令。对Mortar步兵，由于OFP中fire命令对步兵无效，暂时不设置。
	+ 顺带修改玩家的Order脚本，将其放入Player目录下的Order子目录
+ ShowPad和ShowGPS添加到Spectator的刷新脚本。
## 2.12 v02
+ Equip
	+ 优化EditRearmData系列功能。
	+ 设置4xAA科技在升级时直接对已有单位进行弹夹编辑。
		+ 将相关脚本放到Common\ReEquip目录下
		+ 另外修复UpgState脚本的bug。在UpgState信息脚本里，理应用当前的传入的数值来判断情况，而非直接从矩阵读取数值，原有bug设计会导致Mag科技升级后，新的科技升级使已有的4xAA弹夹翻倍。
	+ 4xAA不适合用游戏原版机炮，它不发射导弹。更改弹药参数之前，取消机炮的设置。4xAA直接继承步兵AA，其cost值为2W，而机炮的cost只是30而已。
+ Temporary系统
	+ 增设All命令
		+ 修改Dialog脚本
		+ 修改Send/Msg脚本，GroupsNum要×2
		+ 设置ALL对Order锁定的队伍不下达临时性命令。
	+ 坦克切换sabot和heat的临时性命令
		+ 设计命令脚本。只由AI队伍的载具gunner启动，并排除remote载具。
		+ 在Common\ReEquip目录下增设实际的重装填弹夹的脚本，供命令脚本调用。
	+ 顺带将临时性命令，以及Order命令的脚本都扔到Server的子目录下
	+ 修复相当一部分临时性命令脚本中indexType不一致的bug（会导致部分命令根本没有用）。
+ 更换榴弹炮为限制角度的Lim版。
+ 设置死亡爆炸效果的5个收讯脚本，用于常规单位。对于res单位，使用logic来实现效果。
+ 为规避笔记本的异常，TZK_Setting里增设ShowPad的逻辑项。
+ 修复v00中dev模式下敌方图标的bug。dev模式强制显示敌图标，而普通模式会隐藏范围外的图标，导致闪烁。因此敌图标的2个脚本在dev模式下要退出。
## 2.12 v01
+ EventHandler
	+ 修复IncomingMissile的bug。这个EH的特殊性在于，如果希望它响应来自remote端的导弹，remote端必须存在一个挂载于相同载具的EH，即使其command参数为空字符串。
	+ 调整Spoof系列的脚本，修复原有bug，并设置drop效果不会在dedicated server上执行。仍然使用publicExec广播。
+ 修复关于"GetUnitMarker.sqf"中对" REMOTE"字符串忽略考虑的bug。
+ 为4xAA添加机炮，测试效果。
+ 引入油桶编辑后的T80模型。
+ 增加死亡坦克燃烧效果。
+ 增加usmc_gala的新任务。
## 2.12 v00
+ 调整版本号。使用"v00-v99"。
+ 解耦图标刷新模式
	+ 己方单位及载具的图标仍然采用sqf，频率2Hz。
	+ 敌方单位采用SQS，频率≤1Hz，首先计算雷达分布，然后显示飞行单位图标；之后进行间谍卫星判定，然后显示图标。
	+ 建筑则每30秒刷新一次，刷新时不对position进行调整，仅判定isNull与否。对己方建筑，额外有一个alive判定与颜色调整。
	+ 调整主循环的显示机制，对于隐藏图标的其个性，减少隐藏的计算判定。
+ 调整UC的模式，为加强对于高速运动的单位的选取，使用UC点击地图时，将Marker名称一并获取，进而判断图标位置是否与点击坐标接近。 