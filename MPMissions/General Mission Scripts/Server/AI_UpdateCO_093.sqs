; args: [unit, si, gi]

? !isServer : exit

_unit = _this select 0
_si = _this select 1
_gi = _this select 2

_group = (groupMatrix select _si) select _gi

@( !(isNull (mhq select si0)) && !(isNull (mhq select si1)) )

_posIdle = []
_posMove = [0,0]
_return = ""

_base = baseDefs select ((random (count baseDefs)) - 0.5)

_factorBuildTime = ([60, 15] select dev)

_prims = _base select 0
_indexNextPrim = 0
_timeNextPrim = _prims select _indexNextPrim select bdTime
_costNextPrim = structDefs select (_prims select _indexNextPrim select bdType) select sdCost

_secs = _base select 1
_timeCheckBuildSec = 2*60
_objSec = []; { _objSec set [count _objSec, objNull] } foreach _secs

_timeCheckPlayerIncome = 0
_timeCheckNextUpgrade = ([20*60, 60] select dev)
_timeCheckEjectDrivers = ([30*60, 60] select dev)
_timeCheckSupport = 2*60
_timeCheckOrders = 20

_mhq = mhq select _si

_posStart = getPos _mhq
_dirBase = getDir _mhq
_timeCommandGroup = time
_commandInterval = 3*60

_infantry = unitsBuyAI select _si select utbInfMixed; _armor = unitsBuyAI select _si select utbTanksMixed; _air = unitsBuyAI select _si select utbPlane

; special case when an ai group leader becomes co
_unitsStarted = (units _group) - [_unit]

_order = orderMatrix select _si select _gi; _idOrder = _order select 0

? !(alive _unit): goto "WaitUntilAlive"

_unit setCombatMode "YELLOW"; _unit setBehaviour "AWARE"; _unit setSpeedMode "FULL"

[_unit, _si, 200] exec "Common\EventAdd_InfantryKilled.sqs"
[_unit, _si, _gi] exec "Server\EventAdd_Infantry.sqs"
[_unit] exec "Common\AddRearmData.sqs"

_sleep = 5
_giPatrol = _gi; _bTakeTown=false; _nDestroy=0
#Update
	~_sleep
	_sleep = 5
	? !(alive _unit): goto "WaitUntilAlive"

	; check for new order
	? _idOrder == _order select 0: goto "NoNewOrder"
	_idOrder = _order select 0
	_order = (orderMatrix select _si) select _gi
	_script = (orderDefs select (_order select 1)) select 2
	{ [_x, _si, _gi, _order select 2] exec format["Server\Order\%1", _script] } foreach _unitsStarted
	#NoNewOrder
	
	; start ai for new units
	_unitsStarted = _unitsStarted - [objNull]
	_unitsStart = (units _group) - _unitsStarted - [_unit]
	{ [_x, _si, _gi] exec "Server\AI_Start.sqs"; _unitsStarted set [count _unitsStarted, _x] } foreach _unitsStart

	_money = groupMoneyMatrix select _si select _gi

	? _unit call busyCheck : goto "Update"

	_mhq = mhq select _si
	? time > _timeCheckPlayerIncome : [_si] exec "Server\AICO_CheckPlayerIncome.sqs"; _timeCheckPlayerIncome = time + ([5*60, 60] select dev)

	; ? (time > (_timeCommandGroup + _commandInterval) && (count units _group) > 1): goto "CommandGroup"

	? alive _mhq && _indexNextPrim < count _prims && time > _factorBuildTime*_timeNextPrim && _money > (_costNextPrim+1000): goto "BuildPrim"
	? time > _timeCheckBuildSec : goto "CheckBuildSec"

	? (alive _mhq) && (call format["pvWorkers%1 < 10", _si]) && _money >= costWorker : [_si] exec "Server\AddWorker.sqs"; _sleep = 0.5; goto "Update"
	
	? (count _posIdle > 0): _dist = [_posIdle, _unit] call funcCalcDistanceToObject; if (_dist > 5) then { _unit doMove _posIdle }

	? time > _timeCheckNextUpgrade : [_si, _gi] exec "Server\AICO_CheckUpgrade.sqs"; _timeCheckNextUpgrade = time + ([5*60, 60] select dev)

	? (_money > 500): _return = "UnitNotBought"; goto "BuyUnit"

	#UnitNotBought

	? (time > _timeCheckOrders): goto "IssueOrders"

	? !(alive _mhq) && _money > costRepairMHQ : goto "RepairMHQ"

	goto "Update"

#BuyWorker
	[_si] exec "Server\AddWorker.sqs"
	goto "Update"

#BuildPrim
	_buildDesc = _prims select _indexNextPrim
	_structType = _buildDesc select bdType
;	_distStruct = sqrt(((_buildDesc select bdPos) select 0)^2 + ((_buildDesc select bdPos) select 1)^2)
	_structPosRel = [_buildDesc select bdPos, _dirBase] call funcVectorRot
	_structDir = (_buildDesc select bdDir) + _dirBase
	
	_posStruct = [(_posStart select 0) + (_structPosRel select 0), (_posStart select 1) + (_structPosRel select 1) ]

	_structDesc = structDefs select _structType
	_dist = _structDesc select sdDist
	_posMove = [(_posStruct Select 0) - _dist*(sin _structDir), (_posStruct Select 1) - _dist*(cos _structDir)]
	_posWatch = _posStruct

	_return = "BuildPrim_BuildPosReached"; goto "MoveToPos"

	#BuildPrim_BuildPosReached
	_money = groupMoneyMatrix select _si select _gi
  ? _money < _costNextPrim || !(alive _mhq) : goto "Update"
	[_structType, _si, _gi, _posStruct, _structDir] call fBuildStruct

	? _structType == stComm : _posIdle = [(_posStruct Select 0) - 0.5*(_structDesc select sdDist)*(sin _structDir), (_posStruct Select 1) - 0.5*(_structDesc select sdDist)*(cos _structDir)]; _posWatch = _posStruct

	_indexNextPrim = _indexNextPrim + 1
	? !(_indexNextPrim < (count _prims)) : _timeNextPrim = 10000*60; goto "Update"
	_costNextPrim = (structDefs select ((_prims select _indexNextPrim) select bdType)) select sdCost
	_timeNextPrim = (_prims select _indexNextPrim) select bdTime
	
	goto "Update"

#CheckBuildSec
  ; SET AI RESPAWN OBJECT
  _objectRespawn = [_unit, _si] call funcGetNearestRespawnObject
  ? call format["_objectRespawn != pvRespawnObjectAi%1", _si] : call format["pvRespawnObjectAi%1 = _objectRespawn; PublicVariable ""pvRespawnObjectAi%1""", _si]

	_i = 0 
	_c = count _secs
	#CheckBuildSec_CheckObject
	  ? !(_i<_c) : _timeCheckBuildSec = time + 2*60; goto "Update"
    ? time > _factorBuildTime*((_secs select _i) select bdTime) && !(alive (_objSec select _i)) : goto "BuildSec"
    _i = _i + 1
    goto "CheckBuildSec_CheckObject"

#BuildSec
	_buildDesc = _secs select _i
	_structType = _buildDesc select bdType
	_structPosRel = [_buildDesc select bdPos, _dirBase] call funcVectorRot
	_structDir = (_buildDesc select bdDir) + _dirBase
	_posStruct = [(_posStart select 0) + (_structPosRel select 0), (_posStart select 1) + (_structPosRel select 1) ]
	_structDesc = structDefs select _structType
	_dist = _structDesc select sdDist
	_posMove = [(_posStruct Select 0) - _dist*(sin _structDir), (_posStruct Select 1) - _dist*(cos _structDir)]
	_posWatch = _posStruct
	
	_return = "BuildSec_BuildPosReached"; goto "MoveToPos"
	
	#BuildSec_BuildPosReached
	_money = groupMoneyMatrix select _si select _gi
  ? _money < (_structDesc select sdCost) : goto "Update"
	; TODO ? !(alive _mhq) : goto "Update"
	_res = [_structType, _si, _gi, _posStruct, _structDir] call fBuildStruct
	_objSec set [_i, _res select 0]
	goto "Update"

#MoveToPos
	_unit doWatch _posWatch
	_unit doMove _posMove
	_timeForce = time + 120
	#CheckPosReached
		~5
		? !(alive _unit): goto "WaitUntilAlive"
		? time > _timeForce : (vehicle _unit) setPos _posMove; goto _return
		_dist = [_posMove, getPos _unit] call funcDistH
		? _dist > 5 : goto "CheckPosReached"
	doStop _unit
	; _unit doWatch _posWatch
	~2
	? !(alive _unit): goto "WaitUntilAlive"
	goto _return

#BuyUnit
	_res = [_si, [-1, _gi] select ((random 1) < 0.5)] call funcGetSmallestAiGroup
	_giJoin = _res select 0
	_slots = _res select 1

	? (_money > 2000 && ((time > 15*60) || dev) && _slots >= 2): _return = "TankNotBuilt"; goto "BuyTank"
	#TankNotBuilt
	? (_money > 10000 && ((time > 15*60) || dev) && _slots >= 2): _return = "AirNotBuilt"; goto "BuyAir"
	#AirNotBuilt
	_return = "UnitNotBought"
	? (_money > 500 && _slots > 4): goto "BuyInfantry"

	goto _return

#BuyInfantry
	_retries = 10
	#GetRandomInfantry
		_index = random (count _infantry) - 0.5

		_type = (_infantry select _index) select 0
		_cost = (unitDefs select _type) select udCost
		
		? (random 1 < (_infantry select _index) select 1 && _money >= _cost): goto "InfantrySelected"
		_retries = _retries - 1
		? (_retries > 0): goto "GetRandomInfantry"
		goto _return
	
	#InfantrySelected
	_factoryType = (unitDefs select _type) select udFactoryType; _factoryType = _factoryType call funcBinaryDigit; if (count _factoryType > 0) Then {_factoryType = _factoryType select ((count _factoryType) - 1)} Else {goto _return}
	_factory = [_si, _factoryType] call funcGetIdleFactory
	? (isNull _factory): _factory = [_si, _factoryType] call funcGetFactoryWithEmptyQueue

	? !(isNull _factory): [_type, 0, 0, 0, _si, _giJoin, _gi, _factory] exec "Server\BuyUnit.sqs"; goto "Update"

	goto _return

#BuyTank
	_retries = 3
	#GetRandomTank
		_index = random (count _armor) - 0.5

		_type = (_armor select _index) select 0
		_cost = (unitDefs select _type) select udCost
		
		? (random 1 < (_armor select _index) select 1 && _money >= _cost): goto "TankSelected"
		_retries = _retries - 1
		? (_retries > 0): goto "GetRandomTank"
		goto _return
	
	#TankSelected
	_factoryType = (unitDefs select _type) select udFactoryType; _factoryType = _factoryType call funcBinaryDigit; if (count _factoryType > 0) Then {_factoryType = _factoryType select ((count _factoryType) - 1)} Else {goto _return}

	_factory = [_si, _factoryType] call funcGetIdleFactory
	? (isNull _factory): _factory = [_si, _factoryType] call funcGetFactoryWithEmptyQueue

	? !(isNull _factory): [_type, 1, 1, 0, _si, _giJoin, _gi, _factory] exec "Server\BuyUnit.sqs"; goto "Update"

	goto _return

#BuyAir
	_retries = 3
	#GetRandomAir
		_index = random (count _air) - 0.5

		_type = (_air select _index) select 0
		_cost = (unitDefs select _type) select udCost
		
		? (random 1 < (_air select _index) select 1 && _money >= _cost): goto "AirSelected"
		_retries = _retries - 1
		? (_retries > 0): goto "GetRandomAir"
		goto _return
	
	#AirSelected
	_factoryType = (unitDefs select _type) select udFactoryType; _factoryType = _factoryType call funcBinaryDigit; if (count _factoryType > 0) Then {_factoryType = _factoryType select ((count _factoryType) - 1)} Else {goto _return}

	_factory = [_si, _factoryType] call funcGetIdleFactory
	? (isNull _factory): _factory = [_si, _factoryType] call funcGetFactoryWithEmptyQueue

	? !(isNull _factory): [_type, 1, 1, 0, _si, _giJoin, _gi, _factory] exec "Server\BuyUnit.sqs"; goto "Update"
	goto _return

#CommandGroup
	_timeCommandGroup = time
	_units = (units _group) - [_unit]

	; remove 
	_guns = gunMatrix select _si
	_index=0; { if !(alive _x) then { _guns set [_index, objNull] }; _index=_index+1} foreach _guns
	_guns = _guns - [objNull]
	gunMatrix set [_si, _guns]
	_gunsTemp = +_guns

	_index = 0
	_count = count _units
	#CheckAI
		_ai = _units select _index
		? !(alive _ai): goto "CheckNextAI"
		_vcl = vehicle _ai

		? (_vcl != _ai): goto "AIMounted"
		#AIOnFoot
		_gunAssigned = objNull
		_indexGun = 0
		_countGun = count _gunsTemp
		while "isNull _gunAssigned && _indexGun<_countGun" do { _gun = _gunsTemp select _indexGun; if ( (isNull gunner _gun) && (_ai distance _gun)<200 ) then  {_gunAssigned = _gun; _gunsTemp = _gunsTemp - [_gun]}; _indexGun=_indexGun+1 }
		? !(isNull _gunAssigned): _ai assignAsGunner _gunAssigned; [_ai] orderGetIn true; goto "CheckNextAI"
		_posRandom = [_posStart, 200, 500] call funcGetRandomPos
		_ai doMove _posRandom
		
		#AIMounted
		? (_vcl in _guns): goto "CheckNextAI"

		_crew = crew _vcl
		_posRandom = [_posStart, 200, 500] call funcGetRandomPos
		{ _x doMove _posRandom } foreach _crew

		#CheckNextAI
		_index = _index + 1
		? (_index < _count): goto "CheckAI"

	goto "Update"

#IssueOrders
	_timeCheckOrders = time + 10*60
	_townsControlled = 0
	{ if ((_x select tdSide) == _si) then { _townsControlled = _townsControlled + 1 } } foreach towns

	_townsControlledRatio = _townsControlled/(count towns)

	_gis = ([_si] call funcGetAIGroupsIndex)
	_gis = _gis - [_gi]

	? ((count _gis) == 0): goto "OrdersEnd"

	? _townsControlledRatio <= 0.75: [_si, _gi + GroupsNum, orderTakeHoldTowns, [4,([1, 0] select dev)]] exec "Common\SendAIGroupOrder.sqs", [_si, _gi, orderPatrolArea, [0,2]] exec "Common\SendAIGroupOrder.sqs", goto "Update"
	
	_res = [getPos _mhq, _si]  call funcGetClosestEnemyObject
	_object = _res select 0
	? isNull _object : goto "Update"




	[9, getPos _object, _si, _gi] exec "Common\SendSetWPCO.sqs"
	~1




	[_si, _gi + GroupsNum, orderPatrolArea, [9,0]] exec "Common\SendAIGroupOrder.sqs"; _bTakeTown = false
	[_si, _gi, orderPatrolArea, [0,2]] exec "Common\SendAIGroupOrder.sqs"

	#OrdersEnd
	goto "Update"

#RepairMHQ
  _posMove = [getPos _mhq, 2, 3] call funcGetRandomPos
  _posWatch = getPos _mhq
  _return = "MHQReached"; goto "MoveToPos"
  #MHQReached
  (_gi + GroupsNum*_si) exec "Server\RepairMHQ.sqs"
  goto "Update"
  
#WaitUntilAlive
	@(alive leader _group)
	_unit = leader _group

	[_unit, _si, 200] exec "Common\EventAdd_InfantryKilled.sqs"
	[_unit, _si, _gi] exec "Server\EventAdd_Infantry.sqs"
	
	_money = groupMoneyMatrix select _si select _gi

	? _money >= costRespawn : goto "Respawn"
	#WaitMoney
	_unit setPos [-2000 + _si*100, -2000 + _gi*100, 1000]
	; _unit setPos [(posCenter select 0) + _si*100, (posCenter select 1) + _gi*100, 1000]
	_unit setVelocity [0,0,0]
	~1
	_money = groupMoneyMatrix select _si select _gi
	? _money < costRespawn : goto "WaitMoney"

	#Respawn
	? costRespawn > 0 : [_si, _gi, costRespawn] exec "Server\MoneySpend.sqs"
	_objectRespawn = objNull
	call format["_objectRespawn = pvRespawnObjectAi%1", _si]
	? !(alive _objectRespawn) : _objectRespawn = [_objectRespawn, _si] call funcGetNearestRespawnObject

	_ts = _objectRespawn call funcGetStructTypeFromObject
	? _ts != -1 : goto "RespawnStruct"

	#RespawnMHQ
	_mhq = mhq select _si
	_dir = getDir _mhq
	_pos = getPos _mhq
	_posRespawn = [(_pos select 0)-(sin _dir)*10,(_pos select 1)-(cos _dir)*10,0]
  goto "RespawnPosSet"
  
	#RespawnStruct
	_res = [_objectRespawn, _ts, _si] call funcCalcUnitPlacementPosDir
	_posRespawn = _res select 0
	
	#RespawnPosSet
	_unit setVelocity [0,0,0]
	_unit setPos _posRespawn

	[_unit, _si] exec "Server\EquipGroupLeaderAI.sqs"

	[_unit] exec "Common\AddRearmData.sqs"
	_unit setCombatMode "YELLOW"; _unit setBehaviour "AWARE"; _unit setSpeedMode "FULL"

	goto "Update"